[
  {
    "id": "BlobTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst blobTrigger: AzureFunction = async function (context: Context, myBlob: any): Promise<void> {\r\n    context.log(\"Blob trigger function processed blob \\n Name:\", context.bindingData.name, \"\\n Blob Size:\", myBlob.length, \"Bytes\");\r\n};\r\n\r\nexport default blobTrigger;\r\n",
      "readme.md": "# BlobTrigger - TypeScript\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using TypeScript.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation"
    },
    "function": {
      "bindings": [
        {
          "name": "myBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "name": "Azure Blob Storage trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "CosmosDBTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst cosmosDBTrigger: AzureFunction = async function (context: Context, documents: any[]): Promise<void> {\r\n    if (!!documents && documents.length > 0) {\r\n        context.log('Document Id: ', documents[0].id);\r\n    }\r\n}\r\n\r\nexport default cosmosDBTrigger;\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "cosmosDBTrigger",
          "name": "documents",
          "direction": "in",
          "leaseCollectionName": "leases",
          "connectionStringSetting": "",
          "databaseName": "",
          "collectionName": "",
          "createLeaseCollectionIfNotExists": true
        }
      ]
    },
    "metadata": {
      "name": "Azure Cosmos DB trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "DurableFunctionsActivity-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "﻿/*\r\n * This function is not intended to be invoked directly. Instead it will be\r\n * triggered by an orchestrator function.\r\n * \r\n * Before running this sample, please:\r\n * - create a Durable orchestration function\r\n * - create a Durable HTTP starter function\r\n * - run 'npm install durable-functions' from the wwwroot folder of your\r\n *   function app in Kudu\r\n */\r\n\r\nimport { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst activityFunction: AzureFunction = async function (context: Context): Promise<string> {\r\n    return `Hello ${context.bindings.name}!`;\r\n};\r\n\r\nexport default activityFunction;\r\n"
    },
    "function": {
      "bindings": [
        {
          "name": "name",
          "type": "activityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "name": "Durable Functions activity",
      "language": "TypeScript"
    }
  },
  {
    "id": "DurableFunctionsEntity-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "﻿/*\r\n* This function is not intended to be invoked directly. Instead it will be\r\n* triggered by a client function.\r\n* \r\n* Before running this sample, please:\r\n* - create a Durable entity HTTP function\r\n* - run 'npm install durable-functions' from the root of your app\r\n*/\r\n\r\nimport * as df from \"durable-functions\"\r\n\r\nconst entity = df.entity(function (context) {\r\n    const currentValue = context.df.getState(() => 0) as number;\r\n    switch (context.df.operationName) {\r\n        case \"add\":\r\n            const amount = context.df.getInput() as number;\r\n            context.df.setState(currentValue + amount);\r\n            break;\r\n        case \"reset\":\r\n            context.df.setState(0);\r\n            break;\r\n    }\r\n});\r\n\r\nexport default entity;"
    },
    "function": {
      "bindings": [
        {
          "name": "context",
          "type": "entityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "name": "Durable Functions entity",
      "language": "TypeScript"
    }
  },
  {
    "id": "DurableFunctionsEntityHttpStart-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "﻿import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\nimport * as df from \"durable-functions\"\r\n\r\nconst httpStart: AzureFunction = async function (context: Context, req: HttpRequest) {\r\n    const client = df.getClient(context);\r\n    const id: string = req.params.id;\r\n    const entityId = new df.EntityId(\"Counter\", id);\r\n\r\n    if (req.method === \"POST\") {\r\n        // increment value\r\n        await client.signalEntity(entityId, \"add\", 1);\r\n    } else {\r\n        // reads current state of entity\r\n        const stateResponse = await client.readEntityState<number>(entityId);\r\n        return { body: stateResponse.entityState };\r\n    }\r\n};\r\n\r\nexport default httpStart;"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "anonymous",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "route": "counters/{id}",
          "methods": ["post", "get"]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "name": "client",
          "type": "durableClient",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "name": "Durable Functions Entity HTTP starter",
      "language": "TypeScript"
    }
  },
  {
    "id": "DurableFunctionsHttpStart-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "﻿import * as df from \"durable-functions\"\r\nimport { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\n\r\nconst httpStart: AzureFunction = async function (context: Context, req: HttpRequest): Promise<any> {\r\n    const client = df.getClient(context);\r\n    const instanceId = await client.startNew(req.params.functionName, undefined, req.body);\r\n\r\n    context.log(`Started orchestration with ID = '${instanceId}'.`);\r\n\r\n    return client.createCheckStatusResponse(context.bindingData.req, instanceId);\r\n};\r\n\r\nexport default httpStart;\r\n"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "route": "orchestrators/{functionName}",
          "methods": ["post", "get"]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "name": "starter",
          "type": "orchestrationClient",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "name": "Durable Functions HTTP starter",
      "language": "TypeScript"
    }
  },
  {
    "id": "DurableFunctionsOrchestrator-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "﻿/*\r\n * This function is not intended to be invoked directly. Instead it will be\r\n * triggered by an HTTP starter function.\r\n * \r\n * Before running this sample, please:\r\n * - create a Durable activity function (default name is \"Hello\")\r\n * - create a Durable HTTP starter function\r\n * - run 'npm install durable-functions' from the wwwroot folder of your \r\n *    function app in Kudu\r\n */\r\n\r\nimport * as df from \"durable-functions\"\r\n\r\nconst orchestrator = df.orchestrator(function* (context) {\r\n    const outputs = [];\r\n\r\n    // Replace \"Hello\" with the name of your Durable Activity Function.\r\n    outputs.push(yield context.df.callActivity(\"Hello\", \"Tokyo\"));\r\n    outputs.push(yield context.df.callActivity(\"Hello\", \"Seattle\"));\r\n    outputs.push(yield context.df.callActivity(\"Hello\", \"London\"));\r\n\r\n    // returns [\"Hello Tokyo!\", \"Hello Seattle!\", \"Hello London!\"]\r\n    return outputs;\r\n});\r\n\r\nexport default orchestrator;\r\n"
    },
    "function": {
      "bindings": [
        {
          "name": "context",
          "type": "orchestrationTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "name": "Durable Functions orchestrator",
      "language": "TypeScript"
    }
  },
  {
    "id": "EventGridTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst eventGridTrigger: AzureFunction = async function (context: Context, eventGridEvent: any): Promise<void> {\r\n    context.log(typeof eventGridEvent);\r\n    context.log(eventGridEvent);\r\n};\r\n\r\nexport default eventGridTrigger;\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "eventGridTrigger",
          "name": "eventGridEvent",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "name": "Azure Event Grid trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "EventHubTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst eventHubTrigger: AzureFunction = async function (context: Context, eventHubMessages: any[]): Promise<void> {\r\n    context.log(`Eventhub trigger function called for message array ${eventHubMessages}`);\r\n    \r\n    eventHubMessages.forEach((message, index) => {\r\n        context.log(`Processed message ${message}`);\r\n    });\r\n};\r\n\r\nexport default eventHubTrigger;\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "eventHubMessages",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default",
          "dataType": "string"
        }
      ]
    },
    "metadata": {
      "name": "Azure Event Hub trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "HttpTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\n\r\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\r\n    context.log('HTTP trigger function processed a request.');\r\n    const name = (req.query.name || (req.body && req.body.name));\r\n    const responseMessage = name\r\n        ? \"Hello, \" + name + \". This HTTP triggered function executed successfully.\"\r\n        : \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\";\r\n\r\n    context.res = {\r\n        // status: 200, /* Defaults to 200 */\r\n        body: responseMessage\r\n    };\r\n\r\n};\r\n\r\nexport default httpTrigger;"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": ["get", "post"]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "name": "HTTP trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "IoTHubTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst IoTHubTrigger: AzureFunction = async function (context: Context, IoTHubMessages: any[]): Promise<void> {\r\n    context.log(`Eventhub trigger function called for message array: ${IoTHubMessages}`);\r\n    \r\n    IoTHubMessages.forEach(message => {\r\n        context.log(`Processed message: ${message}`);\r\n    });\r\n};\r\n\r\nexport default IoTHubTrigger;\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "IoTHubMessages",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default",
          "dataType": "string"
        }
      ]
    },
    "metadata": {
      "name": "IoT Hub (Event Hub)",
      "language": "TypeScript"
    }
  },
  {
    "id": "KafkaOutput-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\n\r\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\r\n    context.log('HTTP trigger function processed a request.');\r\n    const message = (req.query.message || (req.body && req.body.message));\r\n    const responseMessage = message\r\n        ? \"Message received: \" + message + \". The message transfered to the kafka broker.\"\r\n        : \"This HTTP triggered function executed successfully. Pass a message in the query string or in the request body for a personalized response.\";\r\n    context.bindings.outputKafkaMessage = \"Message : \" + message;\r\n    context.res = {\r\n        // status: 200, /* Defaults to 200 */\r\n        body: responseMessage\r\n    };\r\n\r\n};\r\n\r\nexport default httpTrigger;",
      "readme.md": "# KafkaOutput - TypeScript\r\n\r\nThe `KafkaOutput` makes it incredibly easy to send a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using TypeScript.\r\n\r\n## How it works\r\n\r\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaOutput` attribute according to your broker."
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": ["get", "post"]
        },
        {
          "type": "kafka",
          "name": "outputKafkaMessage",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "SASLSSL",
          "authenticationMode": "PLAIN",
          "direction": "out"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "name": "Kafka output",
      "language": "TypeScript"
    }
  },
  {
    "id": "KafkaTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\n// This is to describe the metadata of a Kafka event\r\nclass KafkaEvent {\r\n    Offset : number;\r\n    Partition : number;\r\n    Topic : string;\r\n    Timestamp : string;\r\n    Value : string;\r\n    \r\n    constructor(metadata:any) {\r\n        this.Offset = metadata.Offset;\r\n        this.Partition = metadata.Partition;\r\n        this.Topic = metadata.Topic;\r\n        this.Timestamp = metadata.Timestamp;\r\n        this.Value = metadata.Value;\r\n    }\r\n\r\n    public getValue<T>() : T {\r\n        return JSON.parse(this.Value).payload;\r\n    }\r\n}\r\n\r\nconst kafkaTrigger: AzureFunction = async function (context: Context, event_str: string): Promise<void> {\r\n\r\n    let event_obj = new KafkaEvent(eval(event_str));\r\n\r\n    context.log(\"Event Offset: \" + event_obj.Offset);\r\n    context.log(\"Event Partition: \" + event_obj.Partition);\r\n    context.log(\"Event Topic: \" + event_obj.Topic);\r\n    context.log(\"Event Timestamp: \" + event_obj.Timestamp);\r\n    context.log(\"Event Value (as string): \" + event_obj.Value);\r\n};\r\n\r\nexport default kafkaTrigger;",
      "readme.md": "# KafkaTrigger - TypeScript\r\n\r\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using TypeScript.\r\n\r\n## How it works\r\n\r\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaTrigger` attribute according to your broker."
    },
    "function": {
      "bindings": [
        {
          "type": "kafkaTrigger",
          "direction": "in",
          "name": "event",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "saslSsl",
          "authenticationMode": "plain",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "name": "Kafka trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "QueueTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst queueTrigger: AzureFunction = async function (context: Context, myQueueItem: string): Promise<void> {\r\n    context.log('Queue trigger function processed work item', myQueueItem);\r\n};\r\n\r\nexport default queueTrigger;\r\n",
      "readme.md": "# QueueTrigger - TypeScript\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation"
    },
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "js-queue-items",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "name": "Azure Queue Storage trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "RabbitMQTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst rabbitmqTrigger: AzureFunction = async function (context: Context, myQueueItem: string): Promise<void> {\r\n    context.log('RabbitMQ trigger function processed work item', myQueueItem);\r\n};\r\n\r\nexport default rabbitmqTrigger;\r\n",
      "readme.md": "# RabbitMQTrigger - C<span>#</span>\r\n\r\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from."
    },
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "rabbitMqTrigger",
          "direction": "in",
          "queueName": "",
          "connectionStringSetting": ""
        }
      ]
    },
    "metadata": {
      "name": "RabbitMQ trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "SendGrid-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\n\r\nconst sendGrid: AzureFunction =  async function (context: Context, order: any): Promise<void> {\r\n    context.log('Queue trigger function processed order', order.orderId);\r\n\r\n    context.bindings.message = {\r\n        subject: `Thanks for your order (#${order.orderId})!`,\r\n        content: [{\r\n            type: 'text/plain',\r\n            value: `${order.customerName}, your order (${order.orderId}) is being processed!`\r\n        }]\r\n    };\r\n}\r\n\r\nexport default sendGrid;\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "queueTrigger",
          "name": "order",
          "direction": "in",
          "queueName": "samples-orders"
        },
        {
          "type": "sendGrid",
          "name": "message",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Azure Functions <samples@functions.com>",
          "to": "{customerEmail}",
          "subject": "",
          "text": ""
        }
      ]
    },
    "metadata": {
      "name": "SendGrid",
      "language": "TypeScript"
    }
  },
  {
    "id": "ServiceBusQueueTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst serviceBusQueueTrigger: AzureFunction = async function(context: Context, mySbMsg: any): Promise<void> {\r\n    context.log('ServiceBus queue trigger function processed message', mySbMsg);\r\n};\r\n\r\nexport default serviceBusQueueTrigger;\r\n"
    },
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myinputqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "name": "Azure Service Bus Queue trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "ServiceBusTopicTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst serviceBusTopicTrigger: AzureFunction = async function(context: Context, mySbMsg: any): Promise<void> {\r\n    context.log('ServiceBus topic trigger function processed message', mySbMsg);\r\n};\r\n\r\nexport default serviceBusTopicTrigger;\r\n"
    },
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "name": "Azure Service Bus Topic trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "SignalRConnectionInfoHttpTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\n\r\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest, connectionInfo: any): Promise<void> {\r\n    context.res.body = connectionInfo;\r\n};\r\n\r\nexport default httpTrigger;\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "anonymous",
          "type": "httpTrigger",
          "direction": "in",
          "methods": ["post"],
          "name": "req",
          "route": "negotiate"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "signalRConnectionInfo",
          "name": "connectionInfo",
          "hubName": "default",
          "connectionStringSetting": "AzureSignalRConnectionString",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "name": "SignalR negotiate HTTP trigger",
      "language": "TypeScript"
    }
  },
  {
    "id": "TimerTrigger-TypeScript",
    "runtime": "3",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst timerTrigger: AzureFunction = async function (context: Context, myTimer: any): Promise<void> {\r\n    var timeStamp = new Date().toISOString();\r\n    \r\n    if (myTimer.isPastDue)\r\n    {\r\n        context.log('Timer function is running late!');\r\n    }\r\n    context.log('Timer trigger function ran!', timeStamp);   \r\n};\r\n\r\nexport default timerTrigger;\r\n",
      "readme.md": "# TimerTrigger - TypeScript\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation"
    },
    "function": {
      "bindings": [
        {
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "name": "Timer trigger",
      "language": "TypeScript"
    }
  }
]
